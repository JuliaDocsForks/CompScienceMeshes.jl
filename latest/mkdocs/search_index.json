{
    "docs": [
        {
            "location": "/", 
            "text": "CompScienceMeshes.jl\n\n\nMeshes, charts, and differential geometry for finite and boundary element solvers.\n\n\n\n\nInstallation\n\n\nIn addition to the dependencies declared in REQUIRE, this package relies for some of its functionality on \ngmsh\n. Make sure \ngmsh\n is installed and on the system path if you require this functionality.\n\n\n\n\nIntroduction\n\n\nThis package provides the geometric framework to facilitated the construction of finite element spaces and the assembly of matrices stemming from the discretisation of local (differential) and global (integral) operators on those finite element spaces.\n\n\nThe package roughly contains three components:\n\n\n\n\nMeshes: allowing for the (almost) linear construction of connectivity matrices. A default implementation is provided but the algorithms should be easily extendable to user defined mesh structures. It is very common, for example, that mesh data structures contain problem specific information (local elasticity, permittivity, boundary conditions). User can use those enriched structures if they extend a limited number of functions.\n\n\nCharts: a concept designed after the differential geometric concept of a chart on a manifold. It allows for the construction of points in Euclidian space from a set of parameters and the other way around.\n\n\nNeighborhoods: a concept designed after the derivative of a chart as a map from the parametrising vector space to the tangent space of a point of the manifold. It allows querying for tangents, normal, and the Jacobian determinant for use in integration routines.\n\n\n\n\n\n\nMesh Interface\n\n\nThis package introduces a minimalistic mesh interface and a standard implementation \nCompScienceMeshes.Mesh\n. The interface is defined by the semantics of the following functions:\n\n\n\n\nFunctions to query a mesh for its characteristics\n\n\n#\n\n\nCompScienceMeshes.dimension\n \n \nMethod\n.\n\n\ndim = dimension(mesh)\n\n\n\n\nReturns the dimension of the mesh. Note that this is the dimension of the cells, not of the surrounding space.\n\n\nsource\n\n\n#\n\n\nCompScienceMeshes.universedimension\n \n \nMethod\n.\n\n\nuniversedimension(mesh)\n\n\n\n\nReturns the dimension of the surrounding space. Equals the number of coordinates required to describe a vertex.\n\n\nsource\n\n\n#\n\n\nCompScienceMeshes.vertextype\n \n \nFunction\n.\n\n\nvt = vertextype(mesh)\n\n\n\n\nReturns type of the vertices used to define the cells of the mesh.\n\n\nsource\n\n\n#\n\n\nCompScienceMeshes.coordtype\n \n \nMethod\n.\n\n\ncoordtype(mesh)\n\n\n\n\nReturns \neltype(vertextype(mesh))\n\n\nsource\n\n\n#\n\n\nCompScienceMeshes.numvertices\n \n \nFunction\n.\n\n\nnumvertices(mesh)\n\n\n\n\nReturns the number of vertices in the mesh.\n\n\nNote\n: this is the number of vertices in the vertex buffer and might include floatin vertices or vertices not appearing in any cell. In other words the following is not necessarily true:\n\n\n    numvertices(mesh) == numcells(skeleton(mesh,0))\n\n\n\n\nsource\n\n\n#\n\n\nCompScienceMeshes.numcells\n \n \nFunction\n.\n\n\nnumcells(mesh)\n\n\n\n\nReturns the number of cells in the mesh.\n\n\nsource\n\n\n\n\nFunctions to iterate over the mesh' cells and the underlying point set\n\n\n#\n\n\nCompScienceMeshes.vertices\n \n \nFunction\n.\n\n\nvertices(mesh)\n\n\n\n\nReturns an indexable iterable to the vertices of the mesh\n\n\nsource\n\n\n#\n\n\nCompScienceMeshes.cells\n \n \nFunction\n.\n\n\ncells(mesh)\n\n\n\n\nReturn an iterable collection containing the cells making up the mesh.\n\n\nsource\n\n\n\n\nFunctions to retrieve adjacency information about the mesh\n\n\n#\n\n\nCompScienceMeshes.skeleton\n \n \nFunction\n.\n\n\nskeleton(mesh, dim)\n\n\n\n\nReturns a mesh comprising the \ndim\n-dimensional sub cells of \nmesh\n. For example to retrieve the edges of a given surface \nmesh\n,\n\n\nedges = skelton(mesh, 1)\n\n\n\n\nsource\n\n\nskeleton(pred, mesh, dim)\n\n\n\n\nLike \nskeleton(mesh, dim)\n, but only cells for which \npred(cell)\n returns true are withheld.\n\n\nsource\n\n\n#\n\n\nCompScienceMeshes.connectivity\n \n \nFunction\n.\n\n\nconnectivity(faces, cells, op=sign)\n\n\n\n\nCreate a sparse matrix \nD\n of size \nnumcells(cells)\n by \nnumcells(faces)\n that contiains the connectivity info of the mesh. In particular \nD[m,k]\n is \nop(r)\n where \nr\n is the local index of face \nk\n in cell \nm\n. The sign of \nr\n is positive or negative depending on the relative orientation of face \nk\n in cell \nm\n.\n\n\nFor \nop=sign\n, the matrix returned is the classic connectivity matrix, i.e. the graph version of the exterior derivative.\n\n\nsource", 
            "title": "Home"
        }, 
        {
            "location": "/#compsciencemeshesjl", 
            "text": "Meshes, charts, and differential geometry for finite and boundary element solvers.", 
            "title": "CompScienceMeshes.jl"
        }, 
        {
            "location": "/#installation", 
            "text": "In addition to the dependencies declared in REQUIRE, this package relies for some of its functionality on  gmsh . Make sure  gmsh  is installed and on the system path if you require this functionality.", 
            "title": "Installation"
        }, 
        {
            "location": "/#introduction", 
            "text": "This package provides the geometric framework to facilitated the construction of finite element spaces and the assembly of matrices stemming from the discretisation of local (differential) and global (integral) operators on those finite element spaces.  The package roughly contains three components:   Meshes: allowing for the (almost) linear construction of connectivity matrices. A default implementation is provided but the algorithms should be easily extendable to user defined mesh structures. It is very common, for example, that mesh data structures contain problem specific information (local elasticity, permittivity, boundary conditions). User can use those enriched structures if they extend a limited number of functions.  Charts: a concept designed after the differential geometric concept of a chart on a manifold. It allows for the construction of points in Euclidian space from a set of parameters and the other way around.  Neighborhoods: a concept designed after the derivative of a chart as a map from the parametrising vector space to the tangent space of a point of the manifold. It allows querying for tangents, normal, and the Jacobian determinant for use in integration routines.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#mesh-interface", 
            "text": "This package introduces a minimalistic mesh interface and a standard implementation  CompScienceMeshes.Mesh . The interface is defined by the semantics of the following functions:", 
            "title": "Mesh Interface"
        }, 
        {
            "location": "/#functions-to-query-a-mesh-for-its-characteristics", 
            "text": "#  CompScienceMeshes.dimension     Method .  dim = dimension(mesh)  Returns the dimension of the mesh. Note that this is the dimension of the cells, not of the surrounding space.  source  #  CompScienceMeshes.universedimension     Method .  universedimension(mesh)  Returns the dimension of the surrounding space. Equals the number of coordinates required to describe a vertex.  source  #  CompScienceMeshes.vertextype     Function .  vt = vertextype(mesh)  Returns type of the vertices used to define the cells of the mesh.  source  #  CompScienceMeshes.coordtype     Method .  coordtype(mesh)  Returns  eltype(vertextype(mesh))  source  #  CompScienceMeshes.numvertices     Function .  numvertices(mesh)  Returns the number of vertices in the mesh.  Note : this is the number of vertices in the vertex buffer and might include floatin vertices or vertices not appearing in any cell. In other words the following is not necessarily true:      numvertices(mesh) == numcells(skeleton(mesh,0))  source  #  CompScienceMeshes.numcells     Function .  numcells(mesh)  Returns the number of cells in the mesh.  source", 
            "title": "Functions to query a mesh for its characteristics"
        }, 
        {
            "location": "/#functions-to-iterate-over-the-mesh-cells-and-the-underlying-point-set", 
            "text": "#  CompScienceMeshes.vertices     Function .  vertices(mesh)  Returns an indexable iterable to the vertices of the mesh  source  #  CompScienceMeshes.cells     Function .  cells(mesh)  Return an iterable collection containing the cells making up the mesh.  source", 
            "title": "Functions to iterate over the mesh' cells and the underlying point set"
        }, 
        {
            "location": "/#functions-to-retrieve-adjacency-information-about-the-mesh", 
            "text": "#  CompScienceMeshes.skeleton     Function .  skeleton(mesh, dim)  Returns a mesh comprising the  dim -dimensional sub cells of  mesh . For example to retrieve the edges of a given surface  mesh ,  edges = skelton(mesh, 1)  source  skeleton(pred, mesh, dim)  Like  skeleton(mesh, dim) , but only cells for which  pred(cell)  returns true are withheld.  source  #  CompScienceMeshes.connectivity     Function .  connectivity(faces, cells, op=sign)  Create a sparse matrix  D  of size  numcells(cells)  by  numcells(faces)  that contiains the connectivity info of the mesh. In particular  D[m,k]  is  op(r)  where  r  is the local index of face  k  in cell  m . The sign of  r  is positive or negative depending on the relative orientation of face  k  in cell  m .  For  op=sign , the matrix returned is the classic connectivity matrix, i.e. the graph version of the exterior derivative.  source", 
            "title": "Functions to retrieve adjacency information about the mesh"
        }, 
        {
            "location": "/charts/", 
            "text": "Charts\n\n\nCharts represent maps from parameter domains to configuration space. Their main use is to provide the geometric description of the cells that make up meshes.\n\n\nThe Chart concept is defined by the following API\n\n\ndimension(ch::CompScienceMeshes.Simplex)\nuniversedimension\nvolume(::CompScienceMeshes.Simplex)\nneighborhood\n\n\n\n\nThe most important example of a Chart is a Simplex. For Simplices, the following additional functions are available\n\n\nsimplex\ncenter", 
            "title": "Charts"
        }, 
        {
            "location": "/charts/#charts", 
            "text": "Charts represent maps from parameter domains to configuration space. Their main use is to provide the geometric description of the cells that make up meshes.  The Chart concept is defined by the following API  dimension(ch::CompScienceMeshes.Simplex)\nuniversedimension\nvolume(::CompScienceMeshes.Simplex)\nneighborhood  The most important example of a Chart is a Simplex. For Simplices, the following additional functions are available  simplex\ncenter", 
            "title": "Charts"
        }, 
        {
            "location": "/neighborhood/", 
            "text": "Neighborhoods\n\n\nThe Neighborhood concept represents the differential geometric notion of the derivative of a chart in a point of its parameter domain. Not only can it be queried for the parametric and cartesian coordinates of the input and output point repsectively, it also contains information on tangents and Jacobian determinants. For the special case where the dimension of the range manifold is one less than that of the surrounding space, access is provided to the unit normal.\n\n\nThis concept is an enriched point concept and should allow the construction of the majority of kernels encountered in fininte and boundary element methods.\n\n\nparametric\ncartesian\njacobian\ntangents\nnormal\n\n\n\n\nIn addition to this interface, a neighborhood has appropriate methods for \ngetindex\n defined, so that it can be used with any function that expects a tuple of coordinates. In other words, a neighborhood is a model for Point.\n\n\n\n\nNumerical Quadrature\n\n\nThis package provides a number of routines that aim to facilitate numerical quadrature over charts. In addition, it includes a default set of quadrature rules for segments (1D) and triangles (2D).\n\n\n#\n\n\nCompScienceMeshes.quadpoints\n \n \nMethod\n.\n\n\npw = quadpoints(chart, rule)\n\n\n\n\nReturns a collection of (point, weight) tuples corresponding to the numerical quadrature \nrule\n defined on the domain of \nchart\n. The weights returned take into account the Jacobian determinant resulting from mapping from the reference domain to the configuration space.\n\n\nFunctions can be integrated like:\n\n\nPW = quadpoints(chart, rule)\nI = sum(pw[2]*f(pw[1]) for pw in PW)\n\n\n\n\nsource", 
            "title": "Neighborhoods"
        }, 
        {
            "location": "/neighborhood/#neighborhoods", 
            "text": "The Neighborhood concept represents the differential geometric notion of the derivative of a chart in a point of its parameter domain. Not only can it be queried for the parametric and cartesian coordinates of the input and output point repsectively, it also contains information on tangents and Jacobian determinants. For the special case where the dimension of the range manifold is one less than that of the surrounding space, access is provided to the unit normal.  This concept is an enriched point concept and should allow the construction of the majority of kernels encountered in fininte and boundary element methods.  parametric\ncartesian\njacobian\ntangents\nnormal  In addition to this interface, a neighborhood has appropriate methods for  getindex  defined, so that it can be used with any function that expects a tuple of coordinates. In other words, a neighborhood is a model for Point.", 
            "title": "Neighborhoods"
        }, 
        {
            "location": "/neighborhood/#numerical-quadrature", 
            "text": "This package provides a number of routines that aim to facilitate numerical quadrature over charts. In addition, it includes a default set of quadrature rules for segments (1D) and triangles (2D).  #  CompScienceMeshes.quadpoints     Method .  pw = quadpoints(chart, rule)  Returns a collection of (point, weight) tuples corresponding to the numerical quadrature  rule  defined on the domain of  chart . The weights returned take into account the Jacobian determinant resulting from mapping from the reference domain to the configuration space.  Functions can be integrated like:  PW = quadpoints(chart, rule)\nI = sum(pw[2]*f(pw[1]) for pw in PW)  source", 
            "title": "Numerical Quadrature"
        }, 
        {
            "location": "/example/", 
            "text": "Computing the genus of a punctured plane\n\n\nIn this example we will compute the genus of a punctured plane. In other words we are interested in the dimension of the 1st homology space.\n\n\nFirst we need to create the mesh. Typically this is done in an external mesher such as \ngmsh\n but here we will construct it from scratch.\n\n\nusing CompScienceMeshes\n\nh = 1/6\nrect = meshrectangle(1.0, 1.0, h, 3)\nhole = meshrectangle(1/3, 1/3, h, 3)\ntranslate!(hole, point(1/3, 1/3, 0))\n\npred = overlap_gpredicate(hole)\nall_faces = submesh(c-\n!pred(chart(rect,c)), rect)\n\n\n\n\nWARNING: min{T1 \n: Real, T2 \n: Real}(x::AbstractArray{T1}, y::AbstractArray{T2}) is deprecated, use min.(x, y) instead.\nStacktrace:\n [1] depwarn(::String, ::Symbol) at ./deprecated.jl:70\n [2] min(::SVector{3,Float64}, ::SVector{3,Float64}) at ./deprecated.jl:57\n [3] @generated body at /home/travis/.julia/v0.7/StaticArrays/src/mapreduce.jl:73 [inlined]\n [4] _mapreduce at /home/travis/.julia/v0.7/StaticArrays/src/mapreduce.jl:65 [inlined]\n [5] mapreduce at /home/travis/.julia/v0.7/StaticArrays/src/mapreduce.jl:57 [inlined]\n [6] reduce at /home/travis/.julia/v0.7/StaticArrays/src/mapreduce.jl:155 [inlined]\n [7] minimum at /home/travis/.julia/v0.7/StaticArrays/src/mapreduce.jl:178 [inlined]\n [8] boundingbox(::CompScienceMeshes.Simplex{3,2,1,3,Float64}) at /home/travis/.julia/v0.7/CompScienceMeshes/src/submesh.jl:66\n [9] (::CompScienceMeshes.#pred#57{CompScienceMeshes.Mesh{3,3,Float64}})(::CompScienceMeshes.Simplex{3,2,1,3,Float64}) at /home/travis/.julia/v0.7/CompScienceMeshes/src/submesh.jl:108\n [10] submesh(::ex-ex1.##1#2, ::CompScienceMeshes.Mesh{3,3,Float64}) at /home/travis/.julia/v0.7/CompScienceMeshes/src/submesh.jl:19\n [11] eval(::Module, ::Any) at ./boot.jl:236\n [12] #8 at /home/travis/.julia/v0.7/Documenter/src/Expanders.jl:459 [inlined]\n [13] cd(::Documenter.Expanders.##8#10, ::String) at ./file.jl:70\n [14] withoutput(::Documenter.Expanders.##7#9{Documenter.Documents.Page}) at /home/travis/.julia/v0.7/Documenter/src/Utilities/Utilities.jl:587\n [15] runner(::Type{Documenter.Expanders.ExampleBlocks}, ::Base.Markdown.Code, ::Documenter.Documents.Page, ::Documenter.Documents.Document) at /home/travis/.julia/v0.7/Documenter/src/Expanders.jl:457\n [16] @generated body at /home/travis/.julia/v0.7/Documenter/src/Selectors.jl:0 [inlined]\n [17] dispatch(::Type{Documenter.Expanders.ExpanderPipeline}, ::Base.Markdown.Code, ::Documenter.Documents.Page, ::Documenter.Documents.Document) at /home/travis/.julia/v0.7/Documenter/src/Selectors.jl:164\n [18] expand(::Documenter.Documents.Document) at /home/travis/.julia/v0.7/Documenter/src/Expanders.jl:29\n [19] @generated body at /home/travis/.julia/v0.7/Documenter/src/Selectors.jl:0 [inlined]\n [20] dispatch(::Type{Documenter.Builder.DocumentPipeline}, ::Documenter.Documents.Document) at /home/travis/.julia/v0.7/Documenter/src/Selectors.jl:164\n [21] cd(::Documenter.##2#3{Documenter.Documents.Document}, ::String) at ./file.jl:70\n [22] #makedocs#1(::Bool, ::Array{Any,1}, ::Function) at /home/travis/.julia/v0.7/Documenter/src/Documenter.jl:198\n [23] (::Documenter.#kw##makedocs)(::Array{Any,1}, ::Documenter.#makedocs) at ./\nmissing\n:0\n [24] include_from_node1(::String) at ./loading.jl:551\n [25] include(::String) at ./sysimg.jl:14\n [26] eval(::Module, ::Any) at ./boot.jl:236\n [27] process_options(::Base.JLOptions) at ./client.jl:288\n [28] _start() at ./client.jl:373\nwhile loading /home/travis/.julia/v0.7/CompScienceMeshes/docs/make.jl, in expression starting on line 3\n\n\n\n\nNote that we started out creating a large rectangular mesh and a small one. Next we translate the small one to the center of the large one. We can use \nsubmesh\n to select the part of the mesh that does not coincide with the hole by providing an appropriate predicate.\n\n\nThe tricky bit is that in order to get the correct number, we need to discard any vertices and edges that lie on the boundary of the structure. To do this we first retrieve a list of all edges and vertices by again calling \nskeleton\n with the appropriate dimension. In a next step we select out those vertices and edges that are not on the boundary.\n\n\nNote\n: \noverlap_predicate\n generates a predicate that takes cells of the same dimensionality as its argument. This means that we first need the 0-skeleton of the boundary before we can create a predicate that takes vertices of the original mesh.\n\n\nall_edges = skeleton(all_faces, 1)\nall_verts = skeleton(all_faces, 0)\n\nbnd_edges = boundary(all_faces)\nbnd_verts = skeleton(bnd_edges, 0)\n\nonbnd1 = overlap_gpredicate(bnd_edges)\nonbnd0 = overlap_gpredicate(bnd_verts)\n\ninterior_edges = submesh(c -\n !onbnd1(chart(all_edges,c)), all_edges)\ninterior_verts = submesh(c -\n !onbnd0(chart(all_verts,c)), all_verts)\n\n\n\n\nThe set of interior_edges looks like this.\n\n\n\n\nThe co-boundary maps are simply the connectivity matrices between cells of the dimension 0-1 and 1-2, respectively. The genus can be computed by simply using the rank nullity theorem, but as part of this example we use the \nrank\n and \nnullspace\n on the connectivty matrices. This if desired can provide a representative of the cohomology space.\n\n\nD0 = connectivity(interior_verts, interior_edges)\nD1 = connectivity(interior_edges, all_faces)\n\nnullity(A) = size(A,2) - rank(A')\ngenus = nullity(full(D1)) - rank(full(D0))\n\n\n\n\n1", 
            "title": "Example"
        }, 
        {
            "location": "/example/#computing-the-genus-of-a-punctured-plane", 
            "text": "In this example we will compute the genus of a punctured plane. In other words we are interested in the dimension of the 1st homology space.  First we need to create the mesh. Typically this is done in an external mesher such as  gmsh  but here we will construct it from scratch.  using CompScienceMeshes\n\nh = 1/6\nrect = meshrectangle(1.0, 1.0, h, 3)\nhole = meshrectangle(1/3, 1/3, h, 3)\ntranslate!(hole, point(1/3, 1/3, 0))\n\npred = overlap_gpredicate(hole)\nall_faces = submesh(c- !pred(chart(rect,c)), rect)  WARNING: min{T1  : Real, T2  : Real}(x::AbstractArray{T1}, y::AbstractArray{T2}) is deprecated, use min.(x, y) instead.\nStacktrace:\n [1] depwarn(::String, ::Symbol) at ./deprecated.jl:70\n [2] min(::SVector{3,Float64}, ::SVector{3,Float64}) at ./deprecated.jl:57\n [3] @generated body at /home/travis/.julia/v0.7/StaticArrays/src/mapreduce.jl:73 [inlined]\n [4] _mapreduce at /home/travis/.julia/v0.7/StaticArrays/src/mapreduce.jl:65 [inlined]\n [5] mapreduce at /home/travis/.julia/v0.7/StaticArrays/src/mapreduce.jl:57 [inlined]\n [6] reduce at /home/travis/.julia/v0.7/StaticArrays/src/mapreduce.jl:155 [inlined]\n [7] minimum at /home/travis/.julia/v0.7/StaticArrays/src/mapreduce.jl:178 [inlined]\n [8] boundingbox(::CompScienceMeshes.Simplex{3,2,1,3,Float64}) at /home/travis/.julia/v0.7/CompScienceMeshes/src/submesh.jl:66\n [9] (::CompScienceMeshes.#pred#57{CompScienceMeshes.Mesh{3,3,Float64}})(::CompScienceMeshes.Simplex{3,2,1,3,Float64}) at /home/travis/.julia/v0.7/CompScienceMeshes/src/submesh.jl:108\n [10] submesh(::ex-ex1.##1#2, ::CompScienceMeshes.Mesh{3,3,Float64}) at /home/travis/.julia/v0.7/CompScienceMeshes/src/submesh.jl:19\n [11] eval(::Module, ::Any) at ./boot.jl:236\n [12] #8 at /home/travis/.julia/v0.7/Documenter/src/Expanders.jl:459 [inlined]\n [13] cd(::Documenter.Expanders.##8#10, ::String) at ./file.jl:70\n [14] withoutput(::Documenter.Expanders.##7#9{Documenter.Documents.Page}) at /home/travis/.julia/v0.7/Documenter/src/Utilities/Utilities.jl:587\n [15] runner(::Type{Documenter.Expanders.ExampleBlocks}, ::Base.Markdown.Code, ::Documenter.Documents.Page, ::Documenter.Documents.Document) at /home/travis/.julia/v0.7/Documenter/src/Expanders.jl:457\n [16] @generated body at /home/travis/.julia/v0.7/Documenter/src/Selectors.jl:0 [inlined]\n [17] dispatch(::Type{Documenter.Expanders.ExpanderPipeline}, ::Base.Markdown.Code, ::Documenter.Documents.Page, ::Documenter.Documents.Document) at /home/travis/.julia/v0.7/Documenter/src/Selectors.jl:164\n [18] expand(::Documenter.Documents.Document) at /home/travis/.julia/v0.7/Documenter/src/Expanders.jl:29\n [19] @generated body at /home/travis/.julia/v0.7/Documenter/src/Selectors.jl:0 [inlined]\n [20] dispatch(::Type{Documenter.Builder.DocumentPipeline}, ::Documenter.Documents.Document) at /home/travis/.julia/v0.7/Documenter/src/Selectors.jl:164\n [21] cd(::Documenter.##2#3{Documenter.Documents.Document}, ::String) at ./file.jl:70\n [22] #makedocs#1(::Bool, ::Array{Any,1}, ::Function) at /home/travis/.julia/v0.7/Documenter/src/Documenter.jl:198\n [23] (::Documenter.#kw##makedocs)(::Array{Any,1}, ::Documenter.#makedocs) at ./ missing :0\n [24] include_from_node1(::String) at ./loading.jl:551\n [25] include(::String) at ./sysimg.jl:14\n [26] eval(::Module, ::Any) at ./boot.jl:236\n [27] process_options(::Base.JLOptions) at ./client.jl:288\n [28] _start() at ./client.jl:373\nwhile loading /home/travis/.julia/v0.7/CompScienceMeshes/docs/make.jl, in expression starting on line 3  Note that we started out creating a large rectangular mesh and a small one. Next we translate the small one to the center of the large one. We can use  submesh  to select the part of the mesh that does not coincide with the hole by providing an appropriate predicate.  The tricky bit is that in order to get the correct number, we need to discard any vertices and edges that lie on the boundary of the structure. To do this we first retrieve a list of all edges and vertices by again calling  skeleton  with the appropriate dimension. In a next step we select out those vertices and edges that are not on the boundary.  Note :  overlap_predicate  generates a predicate that takes cells of the same dimensionality as its argument. This means that we first need the 0-skeleton of the boundary before we can create a predicate that takes vertices of the original mesh.  all_edges = skeleton(all_faces, 1)\nall_verts = skeleton(all_faces, 0)\n\nbnd_edges = boundary(all_faces)\nbnd_verts = skeleton(bnd_edges, 0)\n\nonbnd1 = overlap_gpredicate(bnd_edges)\nonbnd0 = overlap_gpredicate(bnd_verts)\n\ninterior_edges = submesh(c -  !onbnd1(chart(all_edges,c)), all_edges)\ninterior_verts = submesh(c -  !onbnd0(chart(all_verts,c)), all_verts)  The set of interior_edges looks like this.   The co-boundary maps are simply the connectivity matrices between cells of the dimension 0-1 and 1-2, respectively. The genus can be computed by simply using the rank nullity theorem, but as part of this example we use the  rank  and  nullspace  on the connectivty matrices. This if desired can provide a representative of the cohomology space.  D0 = connectivity(interior_verts, interior_edges)\nD1 = connectivity(interior_edges, all_faces)\n\nnullity(A) = size(A,2) - rank(A')\ngenus = nullity(full(D1)) - rank(full(D0))  1", 
            "title": "Computing the genus of a punctured plane"
        }
    ]
}