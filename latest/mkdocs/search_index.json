{
    "docs": [
        {
            "location": "/", 
            "text": "CompScienceMeshes.jl\n\n\nMeshes, charts, and differential geometry for finite and boundary element solvers.\n\n\n\n\nInstallation\n\n\nIn addition to the dependencies declared in REQUIRE, this package relies for some of its functionality on \ngmsh\n. Make sure \ngmsh\n is installed and on the system path if you require this functionality.\n\n\n\n\nIntroduction\n\n\nThis package provides the geometric framework to facilitated the construction of finite element spaces and the assembly of matrices stemming from the discretisation of local (differential) and global (integral) operators on those finite element spaces.\n\n\nThe package roughly contains three components:\n\n\n\n\nMeshes: allowing for the (almost) linear construction of connectivity matrices. A default implementation is provided but the algorithms should be easily extendable to user defined mesh structures. It is very common, for example, that mesh data structures contain problem specific information (local elasticity, permittivity, boundary conditions). User can use those enriched structures if they extend a limited number of functions.\n\n\nCharts: a concept designed after the differential geometric concept of a chart on a manifold. It allows for the construction of points in Euclidian space from a set of parameters and the other way around.\n\n\nNeighborhoods: a concept designed after the derivative of a chart as a map from the parametrising vector space to the tangent space of a point of the manifold. It allows querying for tangents, normal, and the Jacobian determinant for use in integration routines.\n\n\n\n\n\n\nMesh Interface\n\n\nThis package introduces a minimalistic mesh interface and a standard implementation \nCompScienceMeshes.Mesh\n. The interface is defined by the semantics of the following functions:\n\n\n\n\nFunctions to query a mesh for its characteristics\n\n\n#\n\n\nCompScienceMeshes.dimension\n \n \nFunction\n.\n\n\ndimension(simplex)\n\n\n\n\nReturn the manifold dimension of the simplex.\n\n\nsource\n\n\ndimension(mesh)\n\n\n\n\nReturns the dimension of the mesh. Note that this is the dimension of the cells, not of the surrounding space.\n\n\nsource\n\n\n#\n\n\nCompScienceMeshes.universedimension\n \n \nFunction\n.\n\n\nuniversedimension(p)\n\n\nReturn the dimension of the universe in which \np\n is embedded.\n\n\nsource\n\n\nuniversedimension(mesh)\n\n\n\n\nReturns the dimension of the surrounding space. Equals the number of coordinates required to describe a vertex.\n\n\nsource\n\n\n#\n\n\nCompScienceMeshes.vertextype\n \n \nFunction\n.\n\n\nvertextype(mesh)\n\n\n\n\nReturns type of the vertices stored in the mesh\n\n\nsource\n\n\n#\n\n\nCompScienceMeshes.coordtype\n \n \nFunction\n.\n\n\ncoordtype(simplex)\n\n\n\n\nReturn coordinate type used by simplex.\n\n\nsource\n\n\ncoordtype(mesh)\n\n\n\n\nReturns \neltype(vertextype(mesh))\n\n\nsource\n\n\n#\n\n\nCompScienceMeshes.numvertices\n \n \nFunction\n.\n\n\nnumvertices(mesh)\n\n\n\n\nReturns the number of vertices in the mesh.\n\n\nsource\n\n\n#\n\n\nCompScienceMeshes.numcells\n \n \nFunction\n.\n\n\nnumcells(mesh)\n\n\n\n\nReturns the number of cells in the mesh\n\n\nsource\n\n\n\n\nFunctions to iterate over the mesh' cells and the underlying point set\n\n\n#\n\n\nCompScienceMeshes.vertices\n \n \nFunction\n.\n\n\nvertices(mesh)\n\n\n\n\nReturns an indexable iterable to the vertices of the mesh\n\n\nsource\n\n\nvertices(mesh, i)\nvertices(mesh, I)\n\n\n\n\nSelect one or multiple vertices from the mesh. In the second form, only statically sized arrays are allowed to discourage memory allocation. The returned vector in that case will also be statically typed and of the same size as \nI\n.\n\n\nsource\n\n\n#\n\n\nCompScienceMeshes.cells\n \n \nFunction\n.\n\n\ncells(mesh)\n\n\n\n\nReturn an iterable collection containing the cells making up the mesh.\n\n\nsource\n\n\n\n\nFunctions to retrieve adjacency information about the mesh\n\n\n#\n\n\nCompScienceMeshes.skeleton\n \n \nFunction\n.\n\n\nskeleton(mesh, dim)\n\n\n\n\nConverts the faces on an input mesh \nmesh\n into an equal number of simplices     (i.e. the collections of edges that comprise distinct triangles).\n\n\nReturns the cells of dimension \ndim\n as an integer array of size \ndim\n x N where N     is the number of cells of dimension \ndim\n. The integers in this array represent     indices into the vertex buffer of the input mesh. Note that for the special     case \ndim\n == 0 this function does not return any floating vertices.\n\n\nReturns an object of type Mesh comprising the vertices and simpices (i.e. edges)     of the mesh.\n\n\nsource\n\n\nskeleton(pred, mesh, dim)\n\n\n\n\nLike \nskeleton(mesh, dim)\n, but only cells for which \npred(cell)\n returns true are withheld.\n\n\nsource\n\n\n#\n\n\nCompScienceMeshes.vertextocellmap\n \n \nFunction\n.\n\n\nvertextocellmap(mesh) -\n vertextocells, numneighbors\n\n\n\n\nComputed an V\u00d7M array \nvertextocells\n where V is the number of vertices and M is the maximum number of cells adjacent to any given vertex such that \nvertextocells[v,i]\n is the index in the cells of \nmesh\n of the \ni\nth cell adjacent to teh \nv\n-th vertex. \nnumneighbors[v]\n contains the number of cells adjacent to the \nv\n-th vertex.\n\n\nThis method allows e.g. for the efficient computation of the connectivity matrix of the mesh.\n\n\nsource\n\n\n#\n\n\nCompScienceMeshes.connectivity\n \n \nFunction\n.\n\n\nconnectivity(faces, cells, op=sign)\n\n\n\n\nCreate a sparse matrix \nD\n of size \nnumcells(cells)\n by \nnumcells(faces)\n that contiains the connectivity info of the mesh. In particular \nD[m,k]\n is \nop(r)\n where \nr\n is the local index of face \nk\n in cell \nm\n. The sign of \nr\n is positive or negative depending on the relative orientation of face \nk\n in cell \nm\n.\n\n\nFor \nop=sign\n, the matrix returned is the classic connectivity matrix, i.e. the graph version of the exterior derivative.\n\n\nsource\n\n\n#\n\n\nCompScienceMeshes.cellpairs\n \n \nFunction\n.\n\n\ncellpairs(mesh, edges, dropjunctionpair=false) -\n pairs\n\n\n\n\nGiven a mesh and set of oriented edges from that mesh (as generated by \nskeleton\n),     \ncellpairs\n will generate a 2 x K matrix, where K is the number of pairs     and each column contains a pair of indices in the cell array of \nmesh\n that have     one of the supplied edges in common.\n\n\nReturns an array of pairs of indices, each pair corresponding to a pair of adjacent faces.\n\n\n(If the mesh is oriented, the first row of \nfacepairs\n will contain indices to the cell     for which the corresponding edge has a positive relative orientation.\n\n\nIf a edge lies on the boundary of the mesh, and only has one neighboring cell, the     second row of \nfacepairs\n will contain \n-k\n with \nk\n the local index of the corresponding     edge in its neighboring triangle.\n\n\nIf an edge has more than two neighboring cells (i.e. the edge is on a junction),     all possible pairs of cells that have the junction edge in common are supplied. if     \ndropjunctionpair == false\n then one of the possible pairs of cells is not recorded.     This is done to avoid the creation of linearly dependent basis functions in the     construction of boundary element methods for Maxwell's equations.)\n\n\nsource", 
            "title": "Home"
        }, 
        {
            "location": "/#compsciencemeshesjl", 
            "text": "Meshes, charts, and differential geometry for finite and boundary element solvers.", 
            "title": "CompScienceMeshes.jl"
        }, 
        {
            "location": "/#installation", 
            "text": "In addition to the dependencies declared in REQUIRE, this package relies for some of its functionality on  gmsh . Make sure  gmsh  is installed and on the system path if you require this functionality.", 
            "title": "Installation"
        }, 
        {
            "location": "/#introduction", 
            "text": "This package provides the geometric framework to facilitated the construction of finite element spaces and the assembly of matrices stemming from the discretisation of local (differential) and global (integral) operators on those finite element spaces.  The package roughly contains three components:   Meshes: allowing for the (almost) linear construction of connectivity matrices. A default implementation is provided but the algorithms should be easily extendable to user defined mesh structures. It is very common, for example, that mesh data structures contain problem specific information (local elasticity, permittivity, boundary conditions). User can use those enriched structures if they extend a limited number of functions.  Charts: a concept designed after the differential geometric concept of a chart on a manifold. It allows for the construction of points in Euclidian space from a set of parameters and the other way around.  Neighborhoods: a concept designed after the derivative of a chart as a map from the parametrising vector space to the tangent space of a point of the manifold. It allows querying for tangents, normal, and the Jacobian determinant for use in integration routines.", 
            "title": "Introduction"
        }, 
        {
            "location": "/#mesh-interface", 
            "text": "This package introduces a minimalistic mesh interface and a standard implementation  CompScienceMeshes.Mesh . The interface is defined by the semantics of the following functions:", 
            "title": "Mesh Interface"
        }, 
        {
            "location": "/#functions-to-query-a-mesh-for-its-characteristics", 
            "text": "#  CompScienceMeshes.dimension     Function .  dimension(simplex)  Return the manifold dimension of the simplex.  source  dimension(mesh)  Returns the dimension of the mesh. Note that this is the dimension of the cells, not of the surrounding space.  source  #  CompScienceMeshes.universedimension     Function .  universedimension(p)  Return the dimension of the universe in which  p  is embedded.  source  universedimension(mesh)  Returns the dimension of the surrounding space. Equals the number of coordinates required to describe a vertex.  source  #  CompScienceMeshes.vertextype     Function .  vertextype(mesh)  Returns type of the vertices stored in the mesh  source  #  CompScienceMeshes.coordtype     Function .  coordtype(simplex)  Return coordinate type used by simplex.  source  coordtype(mesh)  Returns  eltype(vertextype(mesh))  source  #  CompScienceMeshes.numvertices     Function .  numvertices(mesh)  Returns the number of vertices in the mesh.  source  #  CompScienceMeshes.numcells     Function .  numcells(mesh)  Returns the number of cells in the mesh  source", 
            "title": "Functions to query a mesh for its characteristics"
        }, 
        {
            "location": "/#functions-to-iterate-over-the-mesh-cells-and-the-underlying-point-set", 
            "text": "#  CompScienceMeshes.vertices     Function .  vertices(mesh)  Returns an indexable iterable to the vertices of the mesh  source  vertices(mesh, i)\nvertices(mesh, I)  Select one or multiple vertices from the mesh. In the second form, only statically sized arrays are allowed to discourage memory allocation. The returned vector in that case will also be statically typed and of the same size as  I .  source  #  CompScienceMeshes.cells     Function .  cells(mesh)  Return an iterable collection containing the cells making up the mesh.  source", 
            "title": "Functions to iterate over the mesh' cells and the underlying point set"
        }, 
        {
            "location": "/#functions-to-retrieve-adjacency-information-about-the-mesh", 
            "text": "#  CompScienceMeshes.skeleton     Function .  skeleton(mesh, dim)  Converts the faces on an input mesh  mesh  into an equal number of simplices     (i.e. the collections of edges that comprise distinct triangles).  Returns the cells of dimension  dim  as an integer array of size  dim  x N where N     is the number of cells of dimension  dim . The integers in this array represent     indices into the vertex buffer of the input mesh. Note that for the special     case  dim  == 0 this function does not return any floating vertices.  Returns an object of type Mesh comprising the vertices and simpices (i.e. edges)     of the mesh.  source  skeleton(pred, mesh, dim)  Like  skeleton(mesh, dim) , but only cells for which  pred(cell)  returns true are withheld.  source  #  CompScienceMeshes.vertextocellmap     Function .  vertextocellmap(mesh) -  vertextocells, numneighbors  Computed an V\u00d7M array  vertextocells  where V is the number of vertices and M is the maximum number of cells adjacent to any given vertex such that  vertextocells[v,i]  is the index in the cells of  mesh  of the  i th cell adjacent to teh  v -th vertex.  numneighbors[v]  contains the number of cells adjacent to the  v -th vertex.  This method allows e.g. for the efficient computation of the connectivity matrix of the mesh.  source  #  CompScienceMeshes.connectivity     Function .  connectivity(faces, cells, op=sign)  Create a sparse matrix  D  of size  numcells(cells)  by  numcells(faces)  that contiains the connectivity info of the mesh. In particular  D[m,k]  is  op(r)  where  r  is the local index of face  k  in cell  m . The sign of  r  is positive or negative depending on the relative orientation of face  k  in cell  m .  For  op=sign , the matrix returned is the classic connectivity matrix, i.e. the graph version of the exterior derivative.  source  #  CompScienceMeshes.cellpairs     Function .  cellpairs(mesh, edges, dropjunctionpair=false) -  pairs  Given a mesh and set of oriented edges from that mesh (as generated by  skeleton ),      cellpairs  will generate a 2 x K matrix, where K is the number of pairs     and each column contains a pair of indices in the cell array of  mesh  that have     one of the supplied edges in common.  Returns an array of pairs of indices, each pair corresponding to a pair of adjacent faces.  (If the mesh is oriented, the first row of  facepairs  will contain indices to the cell     for which the corresponding edge has a positive relative orientation.  If a edge lies on the boundary of the mesh, and only has one neighboring cell, the     second row of  facepairs  will contain  -k  with  k  the local index of the corresponding     edge in its neighboring triangle.  If an edge has more than two neighboring cells (i.e. the edge is on a junction),     all possible pairs of cells that have the junction edge in common are supplied. if      dropjunctionpair == false  then one of the possible pairs of cells is not recorded.     This is done to avoid the creation of linearly dependent basis functions in the     construction of boundary element methods for Maxwell's equations.)  source", 
            "title": "Functions to retrieve adjacency information about the mesh"
        }
    ]
}